function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { authenticatedRequest } from "../utils/Http";
const OOTB_3DSPACE_SERVICE_NAME = "3DSpace";
const OOTB_3DSPACE_SERVICE_PATH = "/resources/v1/application/CSRF";
export default class Interface3DSpace {
  constructor(strategy) {
    _defineProperty(this, "resetCsrfPromise", () => {
      this.csrfPromise = this.loadCsrfToken();
    });

    _defineProperty(this, "loadCsrfToken", async () => {
      const _3dspaceUrl = await this.strategy.getCurrentTenantServiceUrl(OOTB_3DSPACE_SERVICE_NAME);

      const tokenUrl = `${_3dspaceUrl}${OOTB_3DSPACE_SERVICE_PATH}`;
      const data = await authenticatedRequest(tokenUrl);
      return data.csrf.value;
    });

    _defineProperty(this, "performCallTo3DSpace", async (url, {
      method,
      data,
      headers = {},
      type,
      deleteType = false,
      useSecurityContext = true,
      useCsrf = true,
      timeout,
      onTimeout,
      onProgress,
      returnHeader = false,
      encodeSecurityContext = false
    }) => {
      const serviceUrl = await this.strategy.getCurrentTenantServiceUrl(OOTB_3DSPACE_SERVICE_NAME);
      const fullUrl = `${serviceUrl}${url}`; // Manipulate headers as a Headers class : this will work in both cases where input headers are provided as Record or as Headers

      const enhancedHeaders = new Headers(headers);

      if (useCsrf) {
        if (!this.csrfPromise) {
          this.resetCsrfPromise();
        }

        const csrfToken = await this.csrfPromise;
        enhancedHeaders.set("ENO_CSRF_TOKEN", csrfToken);
      }

      if (useSecurityContext) {
        const securityContext = await this.strategy.getSecurityContext();
        enhancedHeaders.set("SecurityContext", encodeSecurityContext ? encodeURIComponent(securityContext) : securityContext);
      } // WAFData does not accept a Headers class: it has to be transformed as a Record


      const finalHeaders = {};
      Array.from(enhancedHeaders.entries()).forEach(([key, value]) => finalHeaders[key] = value);
      return authenticatedRequest(fullUrl, {
        method,
        headers: finalHeaders,
        data,
        type,
        deleteType,
        timeout,
        onTimeout,
        onProgress,
        returnHeader
      });
    });

    _defineProperty(this, "call3DSpace", (url, options = {}) => {
      return this.performCallTo3DSpace(url, options).catch(err => {
        var _err$backendresponse, _err$backendresponse$;

        const forbiddenResponseCode = 403;

        if ((err === null || err === void 0 ? void 0 : (_err$backendresponse = err.backendresponse) === null || _err$backendresponse === void 0 ? void 0 : (_err$backendresponse$ = _err$backendresponse.error) === null || _err$backendresponse$ === void 0 ? void 0 : _err$backendresponse$.code) === forbiddenResponseCode) {
          this.csrfPromise = null;
          return this.performCallTo3DSpace(url, options);
        }

        throw err;
      });
    });

    _defineProperty(this, "get3DSpaceServiceUrl", () => {
      return this.strategy.getCurrentTenantServiceUrl(OOTB_3DSPACE_SERVICE_NAME);
    });

    this.strategy = strategy;
    this.csrfPromise = null;
  }

}